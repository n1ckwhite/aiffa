#  Screen Reader: что можно контролировать через role и aria-*

Через `role` и `aria-*` можно направлять, как скринридер озвучивает элементы: скрывать их от AT, давать им имена/описания, сообщать о динамике. Полностью «перехватить» поведение скринридера нельзя — это независимые приложения, следующие WAI‑ARIA и DOM.

---

##  Короткое резюме
- **Можно**: задавать роль, имя, описания; скрывать из AT; управлять динамическими объявлениями (`aria-live`).
- **Нельзя**: навязать собственные алгоритмы чтения, блокировать/перехватывать озвучку произвольно.
- **Что уметь**: грамотно использовать `aria-*`, не конфликтовать с нативной семантикой, тестировать на разных SR. 

---

##  Что реально контролируется

### 1) Исключить элемент из чтения
```html
<span aria-hidden="true"></span>
```
Элемент будет проигнорирован SR, но останется визуально.

### 2) Задать имя/заменить визуальный текст
```html
<button aria-label="Закрыть"></button>
```
SR озвучит «Закрыть», а не символ.

### 3) Связать имя и описания
```html
<label id="username-label" for="username">Имя пользователя</label>
<input id="username" type="text" aria-describedby="username-help" />
<span id="username-help">Введите уникальное имя пользователя</span>
```
SR: «Имя пользователя. Введите уникальное имя пользователя».

### 4) Управлять динамическими объявлениями
```html
<div aria-live="polite">Загрузка завершена!</div>
```
При изменении содержания SR озвучит сообщение.

### 5) Назначить семантическую роль
```html
<div role="button" tabindex="0" aria-label="Добавить в корзину"></div>
```
Элемент будет восприниматься как кнопка; обеспечьте клавиатуру (Enter/Space).

---

##  Ограничения и важные нюансы
- SR ориентируется на DOM и WAI‑ARIA; атрибуты — подсказки, а не жёсткие команды.
- Нет API «перехвата» чтения; поведение отличается у VoiceOver/NVDA/JAWS.
- Избегайте конфликтов: не совмещайте `aria-hidden="true"` с интерактивом внутри; не переопределяйте нативные роли без нужды.

> Важно: если контент временно неактивен — скрывайте его для AT (`hidden`/`display:none`) или переводите фокус/инертность, чтобы SR не «видел» лишнее.

---

##  Примеры 
```html
<!-- Скрытие временного контента -->
<div hidden id="dropdown-menu">…</div>

<!-- Динамическое уведомление (срочное) -->
<div aria-live="assertive">Ошибка сохранения данных!</div>

<!-- Переопределение роли при жёстких ограничениях -->
<div role="button" tabindex="0" aria-label="Добавить"></div>
```

---

##  Практические правила
- Сначала — нативная семантика (`button`, `a[href]`, `input`), потом `role/aria` при необходимости.
- Синхронизируйте визуальные состояния с `aria-*` (`expanded/selected/pressed`).
- Для живых областей чаще используйте `polite`, а `assertive` — только для критики.
- Тестируйте: VoiceOver, NVDA, JAWS; клавиатура; axe/Lighthouse.

---

##  Итог
- `role` и `aria-*` позволяют направлять озвучивание и скрытие для SR, но не дают полного контроля.
- Используйте их, чтобы уточнить семантику и динамику, не ломая ожидания. 

##  ЗАДАЧИ

Набор задач для практики `управление чтением SR`:

---

###  Задача 1: Скрыть декоративный элемент
 Сделайте так, чтобы звёздочка не озвучивалась SR.

```html
<span> Новинка</span>
```

<details>
<summary> Решение</summary>

```html
<span aria-hidden="true"></span> Новинка
```

</details>

---

###  Задача 2: Дать кнопке доступное имя
 Иконка «закрыть» должна читаться как «Закрыть».

```html
<button></button>
```

<details>
<summary> Решение</summary>

```html
<button aria-label="Закрыть"></button>
```

</details>

---

###  Задача 3: Live‑область
 Объявляйте об успехе операции без модалки.

```html
<div id="status" aria-live="polite"></div>
```

<details>
<summary> Решение</summary>

```js
const status = document.getElementById('status');
function reportSaved(){ status.textContent = 'Сохранено'; }
```

</details>

---

##  Самопроверка

1. Можно ли полностью «перехватить» чтение SR и управлять им произвольно?

<details>
<summary> Вывод</summary>
Нет. `role/aria-*` — подсказки; SR следует DOM/WAI‑ARIA и собственным алгоритмам.
</details>

2. Что выбрать для скрытия: `aria-hidden` или `hidden`?

<details>
<summary> Вывод</summary>
`aria-hidden` — скрыть от AT, оставив визуально; `hidden` — полностью убрать из доступного дерева.
</details>

3. Когда уместно `aria-roledescription`?

<details>
<summary> Вывод</summary>
Когда нужно дать пояснение к стандартной роли (не меняя роль).
</details>

---

 Эти задачи помогают закрепить: что именно можно направлять с помощью `role/aria-*`, как скрывать контент от SR и как сообщать о динамике через live‑области.

---