#  Механизм итерации и работа генераторов

Итерация — это процесс последовательного получения значений из набора данных. В JavaScript за этим стоит специальный протокол, состоящий из **итерируемых объектов** и **итераторов**. Генераторы — это удобный инструмент для создания таких итераторов.

## Как работает механизм итерации?

Итерация в JS основана на двух ключевых соглашениях:

###  1. **Итерируемые объекты**
Любой объект, у которого есть метод `Symbol.iterator`, считается итерируемым. Этот метод должен возвращать **итератор**.

```javascript
const iterable = {
  [Symbol.iterator]() {
    return {
      next() {
        return { value: 1, done: true };
      }
    };
  }
};
````

###  2. **Итератор**

Это объект с методом `next()`, который возвращает результат следующего шага итерации:

```
{ value: ..., done: ... }
```

* `value` — следующее значение.
* `done` — булевый флаг, указывающий, завершена ли итерация.

---

## Как используется в `for...of`

Когда `for...of` запускается:

1. Проверяется наличие `Symbol.iterator`.
2. Вызывается метод `next()`, пока `done !== true`.
3. `value` передаётся в теле цикла.

#### Пример:

```javascript
const arr = [10, 20, 30];

for (let val of arr) {
  console.log(val); // 10, 20, 30
}
```

---

## Генераторы как итераторы

**Генератор** — это функция, возвращающая итератор. Она пишется как `function*` и использует `yield`:

```javascript
function* generateNumbers() {
  yield 1;
  yield 2;
  yield 3;
}
```

Такой генератор создаёт итератор, который запоминает своё состояние между вызовами `next()`:

```javascript
const gen = generateNumbers();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
```

---

## Преимущества генераторов

* **Упрощение создания итераторов** — вся логика в одном месте.
* **Пауза и возобновление выполнения** — через `yield`.
* **Ленивая генерация данных** — экономия памяти.
* **Асинхронные генераторы** (`async function*`) — удобно для потоков данных.

---

## Визуально: как работает итерация

```text
[Symbol.iterator] → итератор → .next() → { value, done }
                                  ↓
                            цикл for...of
```

---

##  Итог

Механизм итерации делает JavaScript гибким и мощным. Он лежит в основе `for...of`, `spread`, `Array.from`, и многих других конструкций. Генераторы — это элегантный способ создавать собственные итераторы с минимальным кодом и максимальной читаемостью.

---

##  ЗАДАЧИ

Вот задачи по **механизму итерации и генераторам**, не пересекающиеся с предыдущими. Каждая снабжена кодом, раскрытием вывода и пояснением решения:

---

###  Задача 1: Перебор пользовательского объекта

 Что выведет следующий код?

```javascript
const user = {
  name: "Alex",
  age: 30,
  [Symbol.iterator]() {
    let keys = Object.keys(this);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          return { value: this[keys[index++]], done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for (let val of user) {
  console.log(val);
}
```

<details>
<summary> Вывод</summary>

```
Alex
30
```

**Объяснение**: `Symbol.iterator` создаёт итератор по значениям свойств. Он не обходит `Symbol.iterator` как ключ, так как `Object.keys()` его не включает.

</details>

---

###  Задача 2: Вложенные генераторы

 Что выведет этот код?

```javascript
function* inner() {
  yield 'a';
  yield 'b';
}

function* outer() {
  yield 'start';
  yield* inner();
  yield 'end';
}

for (let val of outer()) {
  console.log(val);
}
```

<details>
<summary> Вывод</summary>

```
start
a
b
end
```

**Объяснение**: `yield* inner()` вставляет все значения из генератора `inner()` внутрь `outer()`. Это удобно для композиции итераций.

</details>

---

###  Задача 3: Генератор с логикой

 Что выведет генератор?

```javascript
function* countdown(from) {
  while (from > 0) {
    yield from--;
  }
}

for (let n of countdown(3)) {
  console.log(n);
}
```

<details>
<summary> Вывод</summary>

```
3
2
1
```

**Объяснение**: Генератор использует `while` и `yield` для поэтапной генерации чисел от `from` до `1`. Поскольку `from--` постфиксный, сперва возвращается значение, потом уменьшается.

</details>

---

###  Задача 4: Генератор + return

 Что будет выведено?

```javascript
function* gen() {
  yield 1;
  return 2;
  yield 3;
}

const g = gen();

console.log(g.next());
console.log(g.next());
console.log(g.next());
```

<details>
<summary> Вывод</summary>

```
{ value: 1, done: false }
{ value: 2, done: true }
{ value: undefined, done: true }
```

**Объяснение**: `return` завершает генератор и возвращает значение как `value`, при этом `done` становится `true`. Все `yield` после `return` игнорируются.

</details>

---

 В данных задачах рассмотрены различные аспекты работы с генераторами и итераторами.
Эти техники позволяют эффективно обрабатывать последовательности данных.

---
