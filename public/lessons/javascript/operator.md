#  Что делает оператор `&` в JavaScript?

Оператор `&` — **побитовый AND**. Он сравнивает **два числа побитово**, и в каждом бите возвращает `1`, только если **оба бита равны 1**. Во всех остальных случаях — `0`.

#### Пример:

```javascript
console.log(5 & 3); // 1
```

#### Почему?

* 5 в двоичной: `0101`
* 3 в двоичной: `0011`
* Результат:       `0001` = `1`

Этот оператор **не работает с логическими значениями**, как `&&`, он **работает с числами**, и его результат — **число**, а не булево значение.

---

##  Что означает `~array.indexOf(item)`?

Это старая идиома, которую часто можно увидеть в старом JavaScript-коде. Давайте разберёмся:

###  Как работает `indexOf()`?

Метод `array.indexOf(item)` возвращает:

* индекс элемента, если он найден (например, `0`, `1`, `5`, и т.д.),
* `-1`, если элемент не найден.

###  Что делает `~`?

Оператор `~` — это **битовое НЕ (NOT)**. Он инвертирует **все биты числа**, т.е. `~n === -(n + 1)`.

* `~1 = -2`
* `~0 = -1`
* `~-1 = 0` ← вот тут главное

#### Пример:

```javascript
let fruits = ["apple", "banana", "orange"];
if (~fruits.indexOf("banana")) {
  console.log("Есть банан!");
}
```

**Пояснение:**

* Если `"banana"` найден, `indexOf` возвращает `1`, `~1 === -2`, а `-2` — truthy.
* Если элемент **не найден**, `indexOf` возвращает `-1`, `~-1 === 0`, а `0` — falsy.

**Итого:** `~indexOf(...)` используется для проверки, **нашли ли элемент** в массиве, не сравнивая напрямую с `-1`.

Но! Это **плохо читается** и считается **антипаттерном**. Лучше писать явно:

```javascript
if (fruits.indexOf("banana") !== -1) { ... }
```

или, в современном JavaScript:

```javascript
if (fruits.includes("banana")) { ... } 
```

---

##  Побитовые операторы: Добро или Зло?

###  Где они полезны:

1. **Флаги и маски**:
   Например, если вы используете бинарные флаги для прав доступа:

   ```javascript
   const READ = 1;       // 0001
   const WRITE = 2;      // 0010
   const EXECUTE = 4;    // 0100
   let permissions = READ | WRITE;

   if (permissions & READ) { console.log("Чтение разрешено"); }
   ```

2. **Оптимизация (очень низкоуровневая)**:
   Используются, когда важна производительность, особенно в играх, шейдерах, численных вычислениях.

3. **Работа с битовыми структурами, буферами и WebAssembly**.

---

###  Когда они вредны:

* В **обычном прикладном коде** (UI, бизнес-логика) они **ухудшают читаемость**.
* `~indexOf` — **непонятная магия**, особенно для начинающих.
* Побитовые операторы могут вести к **непредсказуемым ошибкам**, если вы случайно примените их к нечисловым типам (например, строкам).

---

##  Итог

* Побитовые операторы (`&`, `|`, `~`, `^`, `<<`, `>>`) — **мощный, но нишевый инструмент**.
* Они **не зло сами по себе**, но **их злоупотребление** в неправильном контексте приводит к плохому коду.
* Используйте их, **только когда это действительно нужно**, и делайте код максимально понятным.

##  ЗАДАЧИ

Вот несколько **качественных задач для закрепления** темы **побитовых операторов** (`&`, `|`, `~`, `^`, `<<`, `>>`) и обсуждённой идиомы `~indexOf()`.

---

###  Задача 1: Флаги прав доступа

У вас есть флаги доступа:

```javascript
const READ = 1;   // 0001
const WRITE = 2;  // 0010
const EXECUTE = 4; // 0100
```

Создайте переменную `userPermissions`, в которой разрешены `READ` и `WRITE`. Проверьте, имеет ли пользователь доступ на `EXECUTE`.

```javascript
const userPermissions = READ | WRITE;

console.log(userPermissions & EXECUTE); // ?
```

<details>
<summary> Решение</summary>

```javascript
console.log(userPermissions & EXECUTE); // 0 (нет EXECUTE)
```

</details>

---

###  Задача 2: Быстрая проверка наличия элемента через `~indexOf`

```javascript
const fruits = ["apple", "banana", "grape"];

if (~fruits.indexOf("banana")) {
  console.log(" Банан найден!");
} else {
  console.log(" Банана нет.");
}

if (~fruits.indexOf("melon")) {
  console.log(" Дыня найдена!");
} else {
  console.log(" Дыни нет.");
}
```

<details>
<summary> Вывод</summary>

```javascript
 Банан найден!
 Дыни нет.
```

</details>

---

###  Задача 3: Побитовая маска прав

```javascript
const ADMIN = 1 << 0;  // 0001
const MODERATOR = 1 << 1;  // 0010
const USER = 1 << 2;   // 0100

let role = ADMIN | USER; // пользователь — админ и обычный пользователь

// Проверка: является ли он модератором?
console.log(Boolean(role & MODERATOR)); // ?
```

<details>
<summary> Вывод</summary>

```javascript
false // MODERATOR не включён в роль
```

</details>

---

###  Задача 4: XOR-свап без временной переменной

Поменяйте местами значения двух переменных без использования третьей переменной:

```javascript
let a = 10;
let b = 20;

// Используйте побитовый XOR
a = a ^ b;
b = a ^ b;
a = a ^ b;

console.log(a); // ?
console.log(b); // ?
```

<details>
<summary> Вывод</summary>

```javascript
a = 20
b = 10
```

</details>

---

###  Задача 5: Убедись, что `indexOf` не возвращает `-1`

Проверь результат `~` для различных `indexOf()`:

```javascript
console.log(~(-1)); // ?
console.log(~0);    // ?
console.log(~1);    // ?
```

<details>
<summary> Вывод</summary>

```javascript
~(-1) = 0
~0    = -1
~1    = -2
```

</details>

---

 Эти задачи помогут лучше понять:

* где использовать побитовые операторы уместно;
* как читать старые конструкции типа `~indexOf`;
* как безопасно и правильно проверять роли, флаги, состояния.

---
