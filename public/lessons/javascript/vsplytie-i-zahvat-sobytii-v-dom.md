#  Всплытие и захват событий в DOM

JavaScript обрабатывает события в дереве DOM в три фазы:

1. **Фаза захвата (capturing)** — событие идёт сверху вниз: от корневого элемента (`document`) к целевому.
2. **Целевая фаза (target)** — событие достигло элемента, на котором произошло действие (например, клик).
3. **Фаза всплытия (bubbling)** — событие "поднимается" от целевого элемента обратно вверх к `document`.

Эти фазы позволяют гибко управлять тем, кто первым реагирует на событие.

---

##  1. Захват событий (Event Capturing)

**Захват** — это первая фаза. Здесь событие "спускается" сверху вниз по дереву DOM: от `document` → `html` → `body` → … → до элемента, на котором произошло событие.

#### Чтобы отреагировать на событие в этой фазе, нужно указать `true` как третий аргумент `addEventListener`:

```javascript
parentElement.addEventListener('click', function() {
  console.log('Захват: parent');
}, true);
```

---

##  2. Целевая фаза (Target Phase)

Это момент, когда событие происходит непосредственно на целевом элементе — например, клик мышью по кнопке. Здесь работают все обработчики, назначенные **на сам элемент**, **независимо от фазы**.

---

##  3. Всплытие событий (Event Bubbling)

**Всплытие** — это третья фаза. После обработки события на целевом элементе, оно начинает "подниматься" вверх по DOM — от дочерних к родительским элементам.

#### Это поведение включено **по умолчанию**:

```javascript
parentElement.addEventListener('click', function() {
  console.log('Всплытие: parent');
});
```

---

#### Пример: Визуализация фаз

```html
<div id="outer">
  <div id="inner">
    <button id="btn">Кликни меня</button>
  </div>
</div>
```

```javascript
document.getElementById('outer').addEventListener('click', () => {
  console.log('OUTER - всплытие');
});
document.getElementById('inner').addEventListener('click', () => {
  console.log('INNER - всплытие');
});
document.getElementById('btn').addEventListener('click', () => {
  console.log('BUTTON - таргет');
});
```

Когда пользователь нажмёт на кнопку, в консоль выведется:

```
BUTTON - таргет
INNER - всплытие
OUTER - всплытие
```

#### Если бы вы подключили обработчики с `true` (захват), они сработали бы в обратном порядке — сначала OUTER, потом INNER, потом BUTTON.

---

##  Захват vs Всплытие — Сравнение

| Фаза     | Направление | По умолчанию | Как включить                                              |
| -------- | ----------- | ------------ | --------------------------------------------------------- |
| Захват   | Сверху вниз |             | `addEventListener(..., true)`                             |
| Всплытие | Снизу вверх |             | `addEventListener(..., false)` или без третьего аргумента |

---

##  Прерывание и предотвращение

* `event.stopPropagation()` — останавливает **всплытие или захват**, чтобы событие не шло дальше.
* `event.preventDefault()` — предотвращает **действие браузера** по умолчанию (например, переход по ссылке).

---

##  Итог

Понимание фаз обработки событий:

* Позволяет писать **эффективные обработчики**, особенно при делегировании.
* Помогает избежать **конфликтов между родителями и детьми** в DOM.
* Даёт больше контроля над тем, **когда и где** обрабатывается событие.

##  ЗАДАЧИ

Вот несколько задач, которые помогут вам закрепить понимание `Всплытие и захват событий`:

---

###  Задача 1: Кто сработает первым?

-  У вас есть три вложенных элемента: `div.outer > div.inner > button`. На каждом из них висит `addEventListener('click', ...)`.

-  Вы добавили все обработчики с параметром `true`. Что вы увидите в консоли при клике на кнопку?

<details>
<summary> Вывод</summary>

Обработчики с `true` работают в фазе **захвата**, значит порядок будет:

1. `outer`
2. `inner`
3. `button`

Потом наступит целевая фаза, и если были обычные обработчики (без `true`), сработают ещё и они в порядке всплытия.

</details>

---

###  Задача 2: Останови всплытие

 При клике на кнопку должен сработать только её обработчик. Родительские элементы не должны реагировать. Как этого добиться?

<details>
<summary> Решение</summary>

В обработчике кнопки вызовите:

```javascript
event.stopPropagation();
```

Это прервет цепочку всплытия события вверх по DOM.

</details>

---

###  Задача 3: Отключи переход по ссылке

 Внутри `div` есть `<a href="/logout">Выйти</a>`. Нужно перехватить клик и **не дать перейти по ссылке** — вместо этого выполнить свою функцию выхода.

<details>
<summary> Решение</summary>

```javascript
a.addEventListener('click', function(event) {
  event.preventDefault();
  logout(); // ваша функция выхода
});
```

`preventDefault()` отменит поведение браузера (переход по ссылке).

</details>

---

###  Задача 4: Делегирование и всплытие

 У вас есть список `<ul id="menu">` с множеством `<li>`. Как повесить один обработчик, который реагирует на клик по любому пункту?

<details>
<summary> Решение</summary>

Используйте **всплытие** и делегируйте обработку через `ul`:

```javascript
document.getElementById('menu').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') {
    console.log('Клик по пункту:', event.target.textContent);
  }
});
```

</details>

---

###  Задача 5: Поймай в захвате

 Нужно, чтобы родитель отреагировал на клик **до** того, как сам элемент. Как это сделать?

<details>
<summary> Решение</summary>

Добавьте обработчик родителю с параметром `true`:

```javascript
parent.addEventListener('click', () => {
  console.log('Сначала родитель');
}, true);
```

Так он сработает на этапе **захвата**, до целевого элемента.

</details>

---

 Эти задачи помогают понять, как управлять порядком обработки событий, как перехватывать поведение, и как организовать более эффективные и гибкие интерфейсы.

---