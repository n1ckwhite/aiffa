#  Применение Semver в проекте

Применение принципов SemVer (семантического версионирования) в проекте помогает структурировать процесс управления версиями и поддерживать четкую совместимость между различными версиями.

---

##  1. Основные принципы SemVer

###  **Формат версионирования**

SemVer использует формат `MAJOR.MINOR.PATCH`:

* **MAJOR (x.0.0)** — увеличивается при изменениях, нарушающих обратную совместимость
* **MINOR (0.x.0)** — увеличивается при добавлении новых функций, совместимых с текущей версией
* **PATCH (0.0.x)** — увеличивается при исправлении ошибок без изменений в функциональности

###  **Пример версионирования**

```
1.0.0 → 1.0.1 → 1.1.0 → 1.1.1 → 2.0.0
```

---

##  2. Определение правил версии

###  **Критерии для MAJOR изменений**

* Полное перепроектирование архитектуры
* Изменения API, требующие изменений в коде пользователей
* Удаление функций или методов
* Изменение структуры данных

###  **Критерии для MINOR изменений**

* Добавление новых функций или возможностей
* Расширение существующего API
* Новые методы в классах
* Добавление опций конфигурации

###  **Критерии для PATCH изменений**

* Исправления багов
* Улучшения документации
* Мелкие оптимизации производительности
* Обновления зависимостей

---

##  3. Автоматизация управления версиями

###  **Инструменты для автоматизации**

* **semantic-release** — автоматизирует обновление версий, теги, changelog
* **Commitlint + Husky** — проверяет соответствие коммитов стандартам
* **Senve или GitVersion** — создание тегов и номеров версий

###  **Анализ комментариев к коммитам**

Инструменты анализируют комментарии к коммитам и автоматически обновляют версии:

```bash
# Примеры коммитов
fix: Исправлен баг в обработке данных          # PATCH
feat: Добавлена новая функция обработки файлов # MINOR
BREAKING CHANGE: Изменён формат входных данных  # MAJOR
```

###  **Автоматическое обновление версий**

```json
{
  "scripts": {
    "release": "semantic-release",
    "version": "npm run build && git add -A",
    "postversion": "git push && git push --tags"
  }
}
```

---

##  4. Интеграция с CI/CD

###  **Автоматизация процесса**

Каждая новая версия автоматически:

* Генерируется при мёрже изменений в ветку `main` или `develop`
* Публикуется в систему управления пакетами (npm, PyPI, Docker Hub)
* Добавляется в changelog с описанием изменений

###  **Пример CI/CD конфигурации**

```yaml
# GitHub Actions
name: Release
on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
      - run: npm ci
      - run: npm test
      - run: npm run release
```

---

##  5. Управление ветками

###  **Структура веток**

* **main** — содержит стабильные версии
* **develop** — используется для разработки
* **feature/** — ветки для новых функций
* **fix/** — ветки для исправлений
* **experiment/** — ветки для экспериментов

###  **Workflow веток**

```
feature/new-function → develop → main
fix/bug-fix → develop → main
```

---

##  6. Инструменты и процессы

###  **Conventional Commits**

Стандарт для написания коммитов:

```bash
# Формат: type(scope): description
feat(auth): добавить OAuth аутентификацию
fix(api): исправить обработку ошибок
docs(readme): обновить документацию
style(eslint): исправить форматирование
refactor(utils): переписать функцию валидации
test(api): добавить тесты для новых методов
chore(deps): обновить зависимости
```

###  **Автоматизация changelog**

```json
{
  "semantic-release": {
    "branches": ["main"],
    "plugins": [
      "@semantic-release/commit-analyzer",
      "@semantic-release/release-notes-generator",
      "@semantic-release/changelog",
      "@semantic-release/npm",
      "@semantic-release/git",
      "@semantic-release/github"
    ]
  }
}
```

---

##  7. Практические примеры

###  **Пример MAJOR изменения**

```javascript
// Версия 1.x.x
function processData(data) {
  return { result: data };
}

// Версия 2.0.0 - BREAKING CHANGE
function processData(data, options = {}) {
  return { 
    processed: data,
    metadata: options.metadata || {}
  };
}
```

###  **Пример MINOR изменения**

```javascript
// Версия 1.2.x
class DataProcessor {
  process(data) { /* ... */ }
}

// Версия 1.3.0 - новая функция
class DataProcessor {
  process(data) { /* ... */ }
  validate(data) { /* ... */ } // новый метод
}
```

###  **Пример PATCH изменения**

```javascript
// Версия 1.2.3 - баг
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Версия 1.2.4 - исправление
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + (item.price || 0), 0);
}
```

---

##  8. Преимущества подхода

###  **Прозрачность**

* Легко понять, что изменилось в каждой версии
* Автоматические changelog
* Понятная история изменений

###  **Стабильность**

* Пользователи знают, какие версии совместимы
* Предсказуемые обновления
* Снижение рисков при обновлении

###  **Автоматизация**

* Меньше ошибок при ручном обновлении версий
* Автоматическое создание релизов
* Интеграция с CI/CD

---

##  Итог

| Аспект | Описание | Результат |
|--------|----------|-----------|
| **Правила** | Четкие критерии для версий | Консистентность |
| **Автоматизация** | Инструменты для управления | Снижение ошибок |
| **CI/CD** | Интеграция с процессами | Быстрые релизы |
| **Ветки** | Структурированная работа | Организованность |
| **Инструменты** | Conventional Commits | Стандартизация |

##  ЗАДАЧИ

Задачи по теме `Применение Semver в проекте`

---

###  Задача 1: Определить тип коммита

Определите, какой тип версии увеличится для коммитов: "fix: исправить баг в валидации", "feat: добавить новый метод", "BREAKING CHANGE: удалить устаревшую функцию", "docs: обновить README".

<details>
<summary> Решение</summary>

**Ответ:** fix → PATCH, feat → MINOR, BREAKING CHANGE → MAJOR, docs → PATCH.

**Объяснение:** fix и docs — исправления, feat — новая функция, BREAKING CHANGE — несовместимые изменения.

</details>

---

###  Задача 2: Выбрать инструмент

Какой инструмент лучше использовать для автоматизации Semver: semantic-release, Senve, GitVersion, ручное управление версиями?

<details>
<summary> Решение</summary>

**Ответ:** semantic-release — лучший выбор для большинства проектов, так как он автоматизирует весь процесс и интегрируется с CI/CD.

**Объяснение:** semantic-release анализирует коммиты, создает версии, теги и changelog автоматически.

</details>

---

###  Задача 3: Определить workflow

Какой workflow правильный для Semver: feature → main, feature → develop → main, feature → main → develop, feature → develop?

<details>
<summary> Решение</summary>

**Ответ:** feature → develop → main — правильный workflow, так как develop используется для интеграции, а main содержит стабильные версии.

**Объяснение:** develop позволяет тестировать изменения перед релизом в main.

</details>

---

 Этот подход помогает не только в управлении версиями, но и в улучшении качества кода и процесса разработки.

---
