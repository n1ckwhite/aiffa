#  Минимизация и оптимизация бандлов

Оптимизация бандлов напрямую влияет на скорость загрузки и UX. Ключевые техники: **tree-shaking**, **code splitting**, **минификация**, **lazy loading**, **оптимизация ассетов**, **кэширование** и **modern builds**. Инструменты (Webpack, Rollup, Parcel, Vite) предоставляют большинство из них «из коробки» или через плагины.

---

##  Основные подходы

- **Tree-shaking**: удаление неиспользуемого кода (ESM, production-режим)
- **Code splitting**: динамические импорты, vendor/common/runtime чанки
- **Минификация**: Terser (JS), CSSNano/PostCSS (CSS)
- **Анализ бандла**: Bundle Analyzer, Source Map Explorer
- **Оптимизация ассетов**: WebP/AVIF, WOFF2, Imagemin, PurgeCSS
- **Кэширование**: `[contenthash]`, долгоживущие заголовки, split runtime
- **CDN/externals**: вынесение тяжелых библиотек
- **Modern builds**: таргет современных браузеров, выборочно подключаемые полифилы

---

##  Подходы: пояснения (коротко и по делу)

- **Tree-shaking**
  - Что это: удаление неиспользуемого кода.
  - Как применять: ES Modules (import/export), production-режим; библиотеки с `sideEffects: false`; точечные импорты (например, `lodash-es`).
  - Проверка: в Bundle Analyzer исчезают «мертвые» экспорты; вес чанков снижается.
  - Подводные камни: динамический `require`, реэкспорт «всё сразу», побочные эффекты в модулях.

- **Code splitting**
  - Что это: деление кода на чанки для загрузки «по требованию».
  - Как применять: `import()` по маршрутам/фичам; в Webpack — `splitChunks` (vendors/common) и отдельный `runtimeChunk`.
  - Проверка: стартовый JS меньше; LCP/TTI лучше; число запросов не чрезмерное.
  - Подводные камни: микрочанки (<10–20 KB), дубли зависимостей — настройте `cacheGroups`.

- **Минификация**
  - Что это: сжатие JS/CSS (удаление пробелов/комментов, сокращение имён, dead-code elimination).
  - Как применять: Terser (JS), CSSNano/PostCSS (CSS).
  - Проверка: сравните размеры до/после; сделайте быстрый smoke-тест UI.
  - Подводные камни: агрессивные опции (например, `mangle.toplevel`) могут ломать код с побочными эффектами.

- **Анализ бандла**
  - Что это: визуальный разбор состава бандлов.
  - Как применять: Webpack Bundle Analyzer/Source Map Explorer; ищите тяжёлые пакеты, дубли версий, скрытые локали.
  - Что делать дальше: точечные импорты; `moment` → `dayjs`/`date-fns`; исключение/ленивая загрузка локалей.

- **Оптимизация ассетов**
  - Изображения: WebP/AVIF + fallback (picture/srcset), responsive sizes; компрессия (Imagemin); `loading="lazy"`.
  - Шрифты: WOFF2 + WOFF fallback, ограничить начертания, `font-display: swap`, сабсеттинг.
  - CSS: удаление неиспользуемых стилей (PurgeCSS) с «белым списком» динамических классов; критический CSS при необходимости.

- **Кэширование и хэширование**
  - Что это: повторное использование неизменённых файлов.
  - Как применять: `[contenthash]` в именах; отдельный runtime-чанк; долгие Cache-Control для статики, короткие — для HTML.
  - Проверка: при релизе меняются только файлы с реальными правками; 304/200 как ожидается.

- **CDN и externals**
  - Что это: вынести тяжёлые библиотеки из бандла и подключать их через CDN.
  - Как применять: `externals`; скрипты с `integrity`/`crossorigin`; кэш между сайтами.
  - Риски: внешняя доступность, версии, CSP.

- **Lazy loading**
  - Что это: загрузка ресурсов только когда они нужны.
  - Как применять: `import()` для виджетов/страниц; `loading="lazy"` для изображений/iframe; prefetch вероятных маршрутов.
  - Комфорт: карты, графики, редакторы — лениво; префетч сглаживает холодный старт.

- **Modern builds и полифилы**
  - Что это: современный код — современным браузерам (меньше и быстрее).
  - Как применять: modern mode (Vite/Rollup), `browserslist`; подключать полифилы «по требованию» (`core-js`).
  - Риски: следите за долей старых браузеров; не добавляйте «все полифилы».

- **Удаление/замена зависимостей**
  - Что это: выбросить лишнее, заменить тяжёлое лёгким.
  - Как применять: аудит analyzer’ом; убрать дубли версий; альтернативы (nanoid вместо uuid, date-fns/dayjs вместо moment).
  - Проверка: vendors-чанк уменьшился; метрики Lighthouse улучшились.

- **Доставка (инфраструктура)**
  - Что это: HTTP/2+, gzip/brotli, корректные заголовки.
  - Как применять: включить серверную компрессию; статику отдавать через CDN; настроить MIME/Cache-Control/ETag.
  - Проверка: DevTools Headers (`content-encoding`), transferred vs content size, waterfall без «узких мест».

---

##  Итог

Комбинируйте техники: разрежьте код на нужные чанки, минимизируйте JS/CSS/ассеты, анализируйте состав бандлов, внедряйте кэширование и используйте современные таргеты. Это даст наибольший выигрыш при разумных затратах.

##  ЗАДАЧИ

Вот набор задач, чтобы лучше понять `оптимизацию бандлов`:

---

###  Задача 1: План оптимизации для «тяжёлого» vendor

У вас SPA, где основной бандл небольшой, но чанк `vendors` занимает 1.2 MB из-за `lodash`, `moment`, графических библиотек и UI-фреймворка. Предложите план из 3–5 шагов, который уменьшит вес минимум на 40%, и объясните, как оцените эффект каждого шага до и после.

<details>
<summary> Вывод</summary>

Возможные шаги с обоснованием:
- Точечные импорты: заменить `import _ from 'lodash'` на импорт отдельных методов или `lodash-es` (лучший tree-shaking). Оценка: сравнить размер vendors до/после через Bundle Analyzer.
- Замена `moment` на `date-fns`/`dayjs`, убрать локали или подключать их динамически. Оценка: проверить исключённые локали и размер чанкa.
- Выделить тяжёлые пакеты в отдельные async-чанки (lazy load по маршрутам/экранам). Оценка: TTI/Route-based split — меньше стартовый JS.
- Вынести UI-фреймворк/иконпак в отдельный чанк и/или загрузить через CDN как external. Оценка: vendors↓, кэш CDN↑.
- Удалить неиспользуемые компоненты/иконки, включить sideEffects=false там, где безопасно. Оценка: сравнение tree-shaking отчётов.

Метрики: размер чанков (KB/MB), количество запросов, стартовый JS, Web Vitals (LCP/TTI) на ключевом маршруте.

</details>

---

###  Задача 2: Стратегия code splitting для маршрутов

Приложение с 5 основными страницами (Dashboard, Reports, Settings, Profile, Admin). Нужно уменьшить стартовый бандл и улучшить переходы. Предложите стратегию разбиения на чанки, включая vendor/common/runtime, и объясните, как избежите «дробления ради дробления».

<details>
<summary> Вывод</summary>

Рекомендации:
- Route-level splitting: отдельные чанки на каждую страницу (lazy import по маршруту).
- Vendors: общий чанк `vendors` для стабильно используемых зависимостей (react, router). Очень тяжёлые зависимости — в ленивые чанки страниц, которые их используют.
- Common: вынести общие модули, используемые 2+ страницами (например, утилиты), но следить, чтобы не появлялись микрочанки <10–20 KB.
- Runtime chunk: отдельный `runtime` для лучшего кэширования.
- Префетч/прелоад: prefetch для вероятных следующих страниц, preload — для критичных зависимостей первого экрана.
- Проверка: профилировать переходы в DevTools Coverage + Lighthouse, убедиться, что количество запросов разумно, а стартовый JS заметно уменьшился.

</details>

---

###  Задача 3: Оптимизация ассетов и CSS без регрессий

Проект использует множество изображений, веб-шрифтов и большую CSS-таблицу стилей. Оптимизируйте ассеты и CSS так, чтобы не сломать отображение у пользователей со старыми браузерами и медленным интернетом. Опишите стратегию и контроль рисков.

<details>
<summary> Вывод</summary>

Подход:
- Изображения: генерировать WebP/AVIF + fallback (picture/srcset), настроить responsive sizes; lazy loading (`loading=lazy`) для внеэкраных.
- Шрифты: использовать WOFF2 + WOFF fallbacks, ограничить начертания; `font-display: swap` для быстрой отрисовки; subset шрифтов.
- CSS: включить минификацию (CSSNano) и PurgeCSS/Content-aware removal, но с «белым списком» классов, генерируемых динамически (например, от UI-библиотек). Критический CSS — по необходимости.
- Кэширование: `[contenthash]` для CSS/шрифтов/картинок, долгие cache-control заголовки.
- Контроль рисков: визуальные регрессии проверять скриншот-тестами и Lighthouse; ручной аудит «белого списка» PurgeCSS; fallback-форматы для старых браузеров.

Метрики: общий вес ассетов, First Contentful Paint, время загрузки шрифтов, количество ненужных CSS-правил (Coverage).

</details>

---

 Эти задачи помогут продумать комплексные стратегии уменьшения бандлов: от структуры чанков до ассетов и кэшей, с акцентом на измеримость и контроль рисков.

---
